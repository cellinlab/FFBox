<template>
	<div id="app">
		<main-frame></main-frame>
	</div>
</template>

<script lang="ts">
const version = '3.0'
const buildNumber = 10
//	1.0	1.1	2.0	2.1	2.2	2.3	2.4 2.5 2.6 3.0

import MainFrame from './containers/MainFrame.vue'
import Vue from 'vue'
import Vuex from 'vuex'

import Popup from './components/floating/Popup/index.js'
import Msgbox from './components/floating/Msgbox/index.js'
import Tooltip from './components/floating/Tooltip/index.js'

let ElectronStore, electronStore, ipc, remote, currentWindow, spawn
if (process.env.IS_ELECTRON) {
	ElectronStore = window.require('electron-store')
	electronStore = new ElectronStore()
	ipc = window.require('electron').ipcRenderer
	remote = window.require('electron').remote
	currentWindow = remote.getCurrentWindow();
	spawn = window.require('child_process').spawn;
}

const maxThreads = 2

import { generator as fGenerator } from '../common/formats'
import { generator as vGenerator } from '../common/vcodecs'
import { generator as aGenerator } from '../common/acodecs'
import { FFBoxService } from "@/service/FFBoxService";

import { defaultParams } from "../common/defaultParams";
import { StoreState, NotificationLevel, ServiceTask, WorkingStatus, TaskStatus } from '@/types/types'

let ffboxService: FFBoxService;
let mainVue: any;

Vue.use(Vuex)
Vue.use(Popup);
Vue.use(Msgbox);
Vue.use(Tooltip);

const store = new Vuex.Store<StoreState>({
	state: {
		// 界面类
		showSponsorCenter: false,
		showInfoCenter: false,
		listSelected: 0,
		paraSelected: 1,
		draggerPos: 60,
		// 非界面类
		notifications: [],
		servers: new Map([
			['local', { tasks: [], ffmpegVersion: '', workingStatus: WorkingStatus.stopped, progress: 0 }]
		]),
		currentServerName: 'local',
		selectedTask: new Set(),
		globalParams: Object.assign({}, defaultParams),
		overallProgressTimerID: NaN,
	},
	getters: {
		currentServer (state) {
			return state.servers.get(state.currentServerName);
		}
	},
	mutations: {
		// 切换显示/不显示打赏中心
		showSponsorCenter_update (state, value: boolean) {
			state.showSponsorCenter = value;
			if (state.showSponsorCenter && state.showInfoCenter) {
				state.showInfoCenter = false;
			}
		},
		// 切换显示/不显示通知中心
		showInfoCenter_update (state, value) {
			state.showInfoCenter = value
			if (state.showSponsorCenter && state.showInfoCenter) {
				state.showSponsorCenter = false
			}
		},
		// 点击开始/暂停按钮
		startNpause (state) {
			let currentServer = state.servers.get(state.currentServerName);
			if (!currentServer) {
				return;
			}
			if (currentServer.workingStatus === WorkingStatus.stopped || currentServer.workingStatus === WorkingStatus.paused) {		// 开始任务
				ffboxService.queueAssign();
			} else {
				ffboxService.queuePause();
			}
		},
		pauseNremove (state, id: number) {
			let currentServer = state.servers.get(state.currentServerName);
			if (!currentServer) {
				return;
			}
			let task = currentServer.tasks[id];
			if (task.status === TaskStatus.TASK_RUNNING) {
				ffboxService.taskPause(id);
			} else if (task.status === TaskStatus.TASK_PAUSED || task.status === TaskStatus.TASK_STOPPING || task.status === TaskStatus.TASK_FINISHED || task.status === TaskStatus.TASK_ERROR) {
				ffboxService.taskReset(id);
			} else if (task.status === TaskStatus.TASK_STOPPED) {
				ffboxService.taskDelete(id);
			}
		},
		dashboardTimer (state, id) {
			var task = state.tasks[id]
			var index = task.taskProgress.length - 1;			// 上标 = 长度 - 1
			var avgTotal = 6, avgCount = 0;						// avgTotal 为权重值，每循环一次 - 1；avgCount 每循环一次加一次权重
			var deltaSysTime = 0, deltaFrame = 0, deltaTime = 0
			while (index > 1 && task.taskProgress.length - index < 6) {													// 数据量按最大 6 条算，忽略第 1 条
				deltaSysTime += (task.taskProgress[index][0] - task.taskProgress[index - 1][0]) * avgTotal;				// x 轴
				deltaFrame += (task.taskProgress[index][1] - task.taskProgress[index - 1][1]) * avgTotal;					// y 轴
				deltaTime += (task.taskProgress[index][2] - task.taskProgress[index - 1][2]) * avgTotal;					// y 轴
				avgCount += avgTotal;
				avgTotal--;
				index--;
			}
			deltaSysTime /= avgCount; deltaFrame /= avgCount; deltaTime /= avgCount;							// 取平均
			index = task.taskProgress.length - 1			// 上标 = 长度 - 1
			var frameK = (deltaFrame / deltaSysTime); var frameB = task.taskProgress[index][1] - frameK * task.taskProgress[index][0];		// b = y1 - x1 * k;
			var timeK = (deltaTime / deltaSysTime); var timeB = task.taskProgress[index][2] - timeK * task.taskProgress[index][0];

			// size 专属处理区域
			var index = task.taskProgress_size.length - 1;	// 上标 = 长度 - 1
			var avgTotal = 3, avgCount = 0;					// avgTotal 为权重值，每循环一次 - 1；avgCount 每循环一次加一次权重
			var deltaSysTime = 0, deltaSize = 0;
			while (index > 0 && task.taskProgress_size.length - index < 3) {												// 数据量按最大 3 条算，无需忽略第 1 条
				deltaSysTime += (task.taskProgress_size[index][0] - task.taskProgress_size[index - 1][0]) * avgTotal;		// x 轴
				deltaSize += (task.taskProgress_size[index][1] - task.taskProgress_size[index - 1][1]) * avgTotal;		// y 轴
				avgCount += avgTotal;
				avgTotal--;
				index--;
			}
			deltaSysTime /= avgCount; deltaSize /= avgCount;	// 取平均
			index = task.taskProgress_size.length - 1;		// 上标 = 长度 - 1
			var sizeK = (deltaSize / deltaSysTime); var sizeB = task.taskProgress_size[index][1] - sizeK * task.taskProgress_size[index][0];

			var sysTime = new Date().getTime() / 1000;
			var currentFrame = frameK * sysTime + frameB;
			var currentTime = timeK * sysTime + timeB;		// 单位：s
			var currentSize = sizeK * sysTime + sizeB;		// 单位：kB
			// console.log("frameK: " + frameK + ", timeK: " + timeK + ", sizeK: " + sizeK);
			// console.log("currentFrame: " + currentFrame + ", currentTime: " + currentTime + ", currentSize: " + currentSize);

			// 界面显示内容：码率、速度、时间、帧
			// 计算方法：码率：Δ大小/Δ时间　速度：（带视频：Δ帧/视频帧速/Δ系统时间　纯音频：Δ时间/Δ系统时间（秒））　时间、帧：平滑
			if (task.before.duration != -1) {
				var progress = currentTime / task.before.duration
				if (isNaN(progress) || progress == Infinity) {
					task.progress.progress = 0
				} else {
					task.progress.progress = progress
				}
			} else {
				task.progress.progress = 0.5;
			}
			if (task.progress.progress < 0.995) {				// 进度满了就别更新了
				task.progress.bitrate = (sizeK / timeK) * 8;
				if (task.before.vframerate != "-") {				// 可以读出帧速，用帧速算更准确
					task.progress.speed = frameK / task.before.vframerate;
				} else {
					task.progress.speed = 0;
				}
				task.progress.time = currentTime;
				task.progress.frame = currentFrame;

				// 平滑处理
				task.progress_smooth.progress = task.progress_smooth.progress * 0.7 + task.progress.progress * 0.3;
				task.progress_smooth.bitrate  = task.progress_smooth.bitrate * 0.9 + task.progress.bitrate * 0.1;
				task.progress_smooth.speed    = task.progress_smooth.speed * 0.6 + task.progress.speed * 0.4;
				task.progress_smooth.time     = task.progress_smooth.time * 0.7 + task.progress.time * 0.3;
				task.progress_smooth.frame    = task.progress_smooth.frame * 0.7 + task.progress.frame * 0.3;
				if (isNaN(task.progress_smooth.bitrate) || task.progress_smooth.bitrate == Infinity) {task.progress_smooth.bitrate = 0;} 
				if (isNaN(task.progress_smooth.speed)) {task.progress_smooth.speed = 0;} 
				if (isNaN(task.progress_smooth.time)) {task.progress_smooth.time = 0;} 
				if (isNaN(task.progress_smooth.frame)) {task.progress_smooth.frame = 0;} 
			} else {
				task.progress.progress = 1;
			}
			task.progress_smooth = JSON.parse(JSON.stringify(task.progress_smooth))
			// state.taskOrder = [...state.taskOrder]			// 刷新 TasksView 的 taskList
		},
		overallProgressTimer (state) {
			if (this.getters.queueTaskCount > 0) {
				var totalTime = 0.000001;
				var totalProcessedTime = 0;
				for (const task of Object.values(state.tasks)) {
					totalTime += task.before.duration;
					totalProcessedTime += task.progress_smooth.progress * task.before.duration;
				}
				var progress = totalProcessedTime / totalTime;
				state.progress = progress
				if (this.getters.workingTaskCount > 0) {
					currentWindow.setProgressBar(parseFloat(progress * 0.99 + 0.01), {mode: "normal"});
				} else {
					state.workingStatus = -1
					currentWindow.setProgressBar(parseFloat(progress * 0.99 + 0.01), {mode: "paused"});
					clearInterval(state.overallProgressTimerID);
				}
			} else {			// 任务全部结束
				if (state.workingStatus == 1) {
					if (!currentWindow.isVisible()) {
						currentWindow.flashFrame(true);
					}
					clearInterval(state.overallProgressTimerID);
				}
				state.workingStatus = 0
				currentWindow.setProgressBar(0, {mode: "none"});
				clearInterval(state.overallProgressTimerID);
			}
		},
		// 发布本地消息（args：msg, level）
		pushMsg (state, args: { message: string, level: NotificationLevel }) {
			// let id = Symbol()
			// state.infos.push({
			// 	msg: args.msg, level: args.level, time: + new Date(), id
			// })
			mainVue.$popup({
				message: args.message,
				level: args.level,
			})
		},
		// 仅弹出气泡，不记录消息
		popup (state, args: { message: string, level: NotificationLevel }) {
			mainVue.$popup({
				message: args.message,
				level: args.level,
			})
		},
		// 删除第 index 条消息
		deleteMsg (state, index) {
			state.infos.splice(index, 1)
		},
		// 更改左侧边栏选择的项目，其中（0~1）更改 list，（2~8）更改 para
		listNparaSelect (state, value) {
			if (value < 2) {
				state.listSelected = value
			} else {
				state.paraSelected = value - 2
			}
		},
		// 拖动参数盒的横杠
		dragParabox (state, value) {
			state.draggerPos = value
		},
		// 修改参数，保存到本地磁盘（args：type (input | video | videoDetail | audio | audioDetail | output), key, value）。args 不传则直接存盘
		changePara (state, args) {
			if (args) {
				switch (args.type) {
					case 'input':
						state.globalParams.input[args.key] = args.value
						break;
					case 'video':
						state.globalParams.video[args.key] = args.value
						break;
					case 'videoDetail':
						state.globalParams.video.detail[args.key] = args.value
						break;
					case 'audio':
						state.globalParams.audio[args.key] = args.value
						break;
					case 'audioDetail':
						state.globalParams.audio.detail[args.key] = args.value
						break;
					case 'output':
						state.globalParams.output[args.key] = args.value
						break;
				}
			}
			// 更改到一些不匹配的值后会导致 getFFmpegParaArray 出错，但是修正代码就在后面，因此仅需忽略它，让它继续运行下去，不要急着更新
			Vue.nextTick(() => {
				Vue.set(state.globalParams, 'paraArray', getFFmpegParaArray('[输入目录]/[输入文件名].[输入扩展名]', state.globalParams.input, state.globalParams.video, state.globalParams.audio, state.globalParams.output))
				// state.globalParams.paraArray = getFFmpegParaArray('[输入文件名]', state.globalParams.input, state.globalParams.video, state.globalParams.audio, state.globalParams.output)
				// state.globalParams = JSON.parse(JSON.stringify(state.globalParams))

				for (const id of state.selectedTask) {
					var task = state.tasks[id]
					task.after = JSON.parse(JSON.stringify(state.globalParams))
					task.paraArray = getFFmpegParaArray(task.filepath, task.after.input, task.after.video, task.after.audio, task.after.output, true)
				}

				// 刷新所有单个任务
				// state.tasks = new Map(state.tasks)	// 更新整个 tasks，因为 TasksView -> computed -> taskList -> this.$store.state.tasks.get(id) 仅监听到 tasks 这层，无法获知取出的单个 task 的变化
				// this.commit('selectedTask_update', new Set([...state.selectedTask]))
				// paraPreview();					// 这句要在上面 for 之后，因为上面的 for 用于同步全局与单个文件
			})

			// 存盘
			clearTimeout(window.saveAllParaTimer)
			window.saveAllParaTimer = setTimeout(() => {
				electronStore.set('input', state.globalParams.input)
				electronStore.set('video', state.globalParams.video)
				electronStore.set('audio', state.globalParams.audio)
				electronStore.set('output', state.globalParams.output)
				console.log("参数已保存")
			}, 700);
		},
		// 使用任务的参数替换参数盒，after 不传值为重置为默认
		replacePara (state, after) {
			if (after) {
				state.globalParams = after
			} else {
				state.globalParams = Object.assign({}, defaultParams)
			}
			Vue.nextTick(() => {
				Vue.set(state.globalParams, 'paraArray', getFFmpegParaArray('[输入目录]/[输入文件名].[输入扩展名]', state.globalParams.input, state.globalParams.video, state.globalParams.audio, state.globalParams.output))
			})
		},
		// 添加任务（args：name, path, callback（传回添加后的 id））
		addTask (state, args) {
			ffboxService.taskAdd(args.path, args.name);
			var id = state.taskIndex++
			// var id = Symbol()
			var task = {
				filename: args.name,
				filepath: args.path,
				before: {
					format: '读取中',
					duration: '--:--:--.--',
					vcodec: '读取中',
					acodec: '读取中',
					vresolution: '读取中',
					vframerate: '读取中',
					vbitrate: '读取中',
					abitrate: '读取中',
				},
				after: JSON.parse(JSON.stringify(state.globalParams)),
				paraArray: [],
				progress: {
					progress: 0,
					bitrate: 0,
					speed: 0,
					time: 0,
					frame: 0,
				},
				progress_smooth: {
					progress: 0,
					bitrate: 0,
					speed: 0,
					time: 0,
					frame: 0,
				},
				FFmpeg: null,
				status: TASK_STOPPED,
				taskProgress: [],					// 用于动态显示进度
				taskProgress_size: [],				// 因为 size 的更新速度很慢，所以单独拎出来
				dashboardTimer: NaN,				// 刷新进度的计时器，刷新间隔 40ms
				lastPaused: new Date().getTime() / 1000,	// 用于暂停后恢复时计算速度
				cmdData: '',
				errorInfo: []
			}
			// state.tasks[id] = task		// 监听不到
			Vue.set(state.tasks, id, task)	// store 中没有 $set，因此使用静态方法更新

			// 更新命令行参数
			task.paraArray = getFFmpegParaArray(task.filepath, task.after.input, task.after.video, task.after.audio, task.after.output, true)

			// FFmpeg 读取媒体信息
			var ffmpeg = new FFmpeg(2, ["-hide_banner", "-i", args.path, "-f", "null"])
			ffmpeg.on("data", (data) => {
				this.commit('cmdDataArrived', { id, msg: data })
			});
			ffmpeg.on('metadata', (input) => {
				task.before.format = input.format
				task.before.duration = input.duration
				task.before.vcodec = input.vcodec == undefined ? "-" : input.vcodec
				task.before.vresolution = input.vcodec == undefined ? "-" : input.vresolution.replace("x", "<br />")
				task.before.vbitrate = input.vbitrate == undefined ? "-" : input.vbitrate
				task.before.vframerate = input.vframerate == undefined ? "-" : input.vframerate
				task.before.format = input.format
				task.before.acodec = input.acodec == undefined ? "-" : input.acodec
				task.before.abitrate = input.abitrate == undefined ? "-" : input.abitrate
			})
			ffmpeg.on("critical", (errors) => {
				var reason = '';
				errors.forEach((value) => {
					reason += value;
				})
				this.commit('pushMsg', { msg: args.path + "：" + reason, level: 2 });
				setTimeout(() => {
					delete state.tasks[id]
				}, 100);
			})
			if (typeof args.callback == 'function') {
				args.callback(id)
			}
		},
		selectedTask_update (state, set) {
			// console.log('selectedTask updated at ' + new Date().getTime())
			state.selectedTask = set
			if (set.size > 0) {
				for (const id of set) {
					this.commit('replacePara', state.tasks[id].after)
					break
				}
			}
		},
		// 接收到 cmd 消息（args：msg, id）
		cmdDataArrived (state, args) {
			// console.log(args.msg)
			if (args.msg.slice(-1) != '\n') {
				args.msg += '\n'
			}
			if (typeof args.id == 'undefined') {
				state.cmdData += args.msg
				if (state.cmdData.length > 40000) {
					state.cmdData = state.cmdData.slice(4000)
				}
			} else {
				var task = state.tasks[args.id]
				task.cmdData += args.msg
				if (task.cmdData.length > 40000) {
					task.cmdData = task.cmdData.slice(4000)
				}
			}
			state.selectedTask = new Set(state.selectedTask)
		},
		// 刷新 FFmpeg 版本信息
		FFmpegVersion_update (state, info) {
			state.FFmpegVersion = info
		},
		// 关闭窗口事件触发时调用
		closeConfirm (state) {
			function readyToClose () {
				ipc.send('exitConfirm');
				ipc.send('close');
			}
			if (this.getters.queueTaskCount > 0) {
				mainVue.$confirm({
					title: '要退出咩？',
					content: `您还有 ${this.getters.queueTaskCount} 个任务未完成，要退出🐴？`,
				}).then(readyToClose);
			} else {
				readyToClose();
			}
		}
	}
})

export default Vue.extend({
	name: 'App',
	components: {
		MainFrame
	},
	methods: {
		handleFFmpegVersion(content: string) {

		},
		handleTasklistUpdate(content: Array<number>) {

		},
		handleTaskUpdate(id: number, content: ServiceTask) {

		},
		handleCmdUpdate(id: number, content: string) {

		},
		handleProgressUpdate(id: number, content: any) {

		},
		handleTaskNotification(id: number, content: string, level: NotificationLevel) {

		},
		handleWorkingStatusUpdate(value: WorkingStatus) {
			
		}
	},
	beforeCreate: function () {
		document.querySelector('body')!.className = "body";
	},
	mounted: function () {
		document.title = 'FFBox v' + version + (process.env.NODE_ENV != 'production' ? 'd' : '');
		window.ffboxService = new FFBoxService();
		ffboxService = window.ffboxService;
		mainVue = this;

		console.warn('正在启动 helper');
		let helper = spawn("FFBoxHelper.exe", undefined, {
			detached: false,
			shell: true,
			encoding: 'utf8'
		});
		helper.stdout.on('data', (data) => {
			console.warn(data.toString());
		})
		setTimeout(() => {
			// 保持最上层
			var hwnd
			ipc.on('hwnd', (event, data) => {
				hwnd = data[0] + data[1] * 2**8 + data[2] * 2**16 + data[3] * 2**24
				console.log(`本窗口 hwnd：` + hwnd)
				helper.stdin.write(`2p${hwnd.toString().padStart(7, '0')}`);
			})
			ipc.send('getHwnd')
		}, 500);

		// 更新全局参数输出
		// this.$set(this.$store.state.globalParams, 'paraArray', getFFmpegParaArray('[输入文件名]', this.$store.state.globalParams.input, this.$store.state.globalParams.video, this.$store.state.globalParams.audio, this.$store.state.globalParams.output))

		console.log('exe 路径：' + remote.app.getPath('exe'))
		console.log('electron 执行路径：' + remote.app.getAppPath())
		console.log('node 路径：' + process.execPath)
		console.log('命令执行根路径：' + process.cwd())
		// console.log('命令执行根路径（resolve）：' + resolve('./'))
		console.log('页面 js 文件路径：' + __dirname)
		
		// 初始化 FFmpeg
		ffboxService.initFFmpeg();
		ffboxService.on('ffmpegVersion', (data) => {
			if (data.content !== '') {
				this.$store.commit('FFmpegVersion_update', data.content);
			} else {
				this.$store.commit('FFmpegVersion_update', '-');
			}
		})
		setTimeout(() => {
			if (!electronStore.has('ffbox.buildNumber') || electronStore.get('ffbox.buildNumber') != buildNumber) {
				this.$store.commit('pushMsg', {
					msg: '欢迎使用 FFBox v' + version + '！',
					level: 0
				});
				electronStore.set('ffbox.buildNumber', buildNumber)
				electronStore.set('input', this.$store.state.globalParams.input)
				electronStore.set('video', this.$store.state.globalParams.video)
				electronStore.set('audio', this.$store.state.globalParams.audio)
				electronStore.set('output', this.$store.state.globalParams.output)
			} else {
				this.$store.commit('replacePara', {
					input: electronStore.get('input'),
					video: electronStore.get('video'),
					audio: electronStore.get('audio'),
					output: electronStore.get('output'),
				});
			}
		}, 0);

		// 挂载退出确认
		ipc.on("exitConfirm", () => this.$store.commit('closeConfirm'));

		// 捐助提示
		setTimeout(() => {
			this.$store.commit('pushMsg', {
				message: '觉得好用的话，可以点击下方状态栏的“支持作者”给 github 上的项目点一个⭐哦～',
				level: 0
			})
		}, 120000)

		const pushMsg = () => {
			this.$store.commit('pushMsg',{
				message: generateRandomStr(Math.random() * 128),
				level: Math.floor(Math.random() * 4)
			})
			setTimeout(() => {
				pushMsg();
			}, 3200);
		}
		function generateRandomStr(num: number) {
			let ret = '';
			for (let i = 0; i < num; i++) {
				ret += String.fromCharCode(Math.floor(Math.random() * 128));
			}
			return ret;
		}
		// 挂载 ffboxService 各种更新事件

	},
	store
})

</script>

<style>
	.body {
		margin: 0;
		padding: 0;
		background-color: transparent;
		user-select: none;
		font-family: "PingFang SC", 苹方, 微软雅黑, "Segoe UI", Consolas, Avenir, Arial, Helvetica, sans-serif, 黑体;
	}
	#app {
		font-weight: 400;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		text-align: center;
		color: hsl(0, 0%, 20%);
		position: relative;
		width: 100vw;
		height: 100vh;
		overflow: hidden;
	}
	content-wrapper {
		border: red 1px solid;
	}

</style>
